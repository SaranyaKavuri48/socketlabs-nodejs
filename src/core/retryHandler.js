'use strict';

//const sendResultEnum = require('./sendResultEnum');

const sendResultEnum = require('../sendResultEnum');
const request = require('request');


class RetryHandler {
    /**
   * Creates a new instance of the SocketLabsClient
   * @param {number} serverId - Your SocketLabs ServerId number.
   * @param {string} apiKey - Your SocketLabs Injection API key
   * @param {string} endpointUrl - The SocketLabs Injection API endpoint Url
   * @param {string} optionalProxy - The http proxy you would like to use.
   * @param {number} requestTimeout  - The timeout occured sending the message.
   * @param {number} retrySettings  - The retry value sent .
   *
   */

    constructor(serverId, apiKey, {

        endpointUrl = null,
        optionalProxy = null,
        requestTimeout = 120,
        retryHandler = null,
    } = {}) {

        /**
         * Your SocketLabs ServerId number.
         */
        this.serverId = serverId;

        /**
         * Your SocketLabs Injection API key
         */
        this.apiKey = apiKey;


        /**
         * The SocketLabs Injection API endpoint Url
         */
        this.userAgent = `SocketLabs-node/${version} (nodejs ${process.version})`;

        /**
         * The SocketLabs Injection API endpoint Url
         */
        //this.endpointUrl = "http://localhost:4433";

        this.endpointUrl = "https://inject.socketlabs.com/api/v1/email";
        if (endpointUrl && endpointUrl !== '') {
            this.endpointUrl = endpointUrl;
        }

        if (optionalProxy && typeof optionalProxy === 'string') {
            request.defaults({
                'proxy': optionalProxy
            });
        }

        requestTimeout = {

            get requestTimeout() {
                return this.requestTimeout;
            },
            set requestTimeout(value) {
                this.requestTimeout = value;
            }
        };

        retryHandler = {
            get retryHandler() {
                return this.retryHandler;
            },
            set retryHandler(value) {
                this.retryHandler = value;
            }

        };
    }

    /**
    * Set the unique key generated by the Injection API if an unexpected error occurs during the SocketLabsClient send request.
    * @param  {string} value
    */


    /**
     * Set the result of the SocketLabsClient send request.
     * @param  {sendResultEnum} value
     */

    setResult(value) {
        var sr;
        if (typeof value === 'undefined' || !value) {
            return;
        }
        else if ((typeof value === 'object') &&
            ('name' in value) &&
            ('value' in value) &&
            ('message' in value)) {


            /**
             * The result of the SocketLabsClient send request.
             */
            this.result = value;
            this.responseMessage = value.message;
        }
        else {
            throw new Error("Invalid sendResult, type of 'sendResultEnum' was expected.");
        }
    }

    static parse(value) {
        console.log(value);
        console.log(value.statusCode);

        switch (value.statusCode) {
            case 200: //HttpStatusCode.OK

                var r = sendResultEnum[body.ErrorCode];
                if (r === undefined) {
                    response.setResult(sendResultEnum.UnknownError);
                }
                else {
                    response.setResult(r);
                }
                break;

            case 500: //HttpStatusCode.InternalServerError
                response.setResult(sendResultEnum.InternalError);
                break;

            case 502: //HttpStatusCode.Bad Gateway
                response.setResult(sendResultEnum.BadGateway);
                return response;
            //break;

            case 503: //HttpStatusCode.Service Unavailable
                response.setResult(sendResultEnum.ServiceUnavailable);
                break;
            case 504: //HttpStatusCode.GatewayTimeout
                response.setResult(sendResultEnum.GatewayTimeout);
                break;

            default:
                response.transactionReceipt = body.transactionReceipt;
                response.setResult(sendResultEnum.UnknownError);

                break;
        }

    }

    SendAsync(content, cancellationToken) {

        if (retrySettings.MaximumNumberOfRetries == 0)
            return await HttpClient


    }
}